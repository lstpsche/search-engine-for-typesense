#!/usr/bin/env ruby
# frozen_string_literal: true

# Docs links & anchors checker (stdlib-only)
# - Scans docs/**/*.md for internal relative links and anchors
# - Verifies file existence and anchor presence (GitHub-like slug)
# - Writes JSON to tmp/docs_audit/links.json
# - Prints counts summary to STDOUT
# - Regenerates consolidated report tmp/refactor/docs_audit.md if other JSONs exist

require_relative 'dev/docs_audit_common'
require 'set'
require 'cgi'

include DocsAudit

DocsAudit.ensure_dirs!

findings = []

DocsAudit.markdown_files.each do |file|
  lines = DocsAudit.read_lines(file)
  anchors_cache = {}

  DocsAudit.extract_markdown_links(lines).each do |lnk|
    target = lnk[:target]
    next if target.nil? || target.empty?

    abs, anchor = DocsAudit.resolve_target(file, target)
    next if abs.nil? # external or unsupported

    # If the path is a directory, try index.md
    suggestion = nil
    path_exists = File.file?(abs)
    if !path_exists && File.directory?(abs)
      idx = File.join(abs, 'index.md')
      if File.file?(idx)
        suggestion = DocsAudit.repo_relative(idx)
        kind = 'maybe_redirect'
        findings << {
          path: DocsAudit.repo_relative(file),
          line: lnk[:line],
          kind: kind,
          link_text: lnk[:text],
          target: target,
          suggestion: suggestion,
          severity: DocsAudit.p_severity(kind)
        }
        next
      end
    end

    # Heuristic: README.md -> index.md
    if !path_exists && abs.end_with?('README.md')
      idx = abs.sub(/README\.md\z/, 'index.md')
      if File.file?(idx)
        kind = 'maybe_redirect'
        findings << {
          path: DocsAudit.repo_relative(file),
          line: lnk[:line],
          kind: kind,
          link_text: lnk[:text],
          target: target,
          suggestion: DocsAudit.repo_relative(idx),
          severity: DocsAudit.p_severity(kind)
        }
        next
      end
    end

    unless File.file?(abs)
      kind = 'missing_file'
      findings << {
        path: DocsAudit.repo_relative(file),
        line: lnk[:line],
        kind: kind,
        link_text: lnk[:text],
        target: target,
        suggestion: nil,
        severity: DocsAudit.p_severity(kind)
      }
      next
    end

    # File exists. Validate anchor if present
    if anchor && !anchor.empty?
      lines2 = (anchors_cache[abs] ||= DocsAudit.read_lines(abs))
      anchors = (anchors_cache["#{abs}:anchors"] ||= DocsAudit.anchors_for(lines2))

      normalized = DocsAudit.slugify(CGI.unescape(anchor))
      unless anchors.include?(normalized)
        kind = 'missing_anchor'
        findings << {
          path: DocsAudit.repo_relative(file),
          line: lnk[:line],
          kind: kind,
          link_text: lnk[:text],
          target: target,
          suggestion: 'Update heading or anchor to match slug',
          severity: DocsAudit.p_severity(kind)
        }
      end
    end

    # Suggest directory-style link if linking to index.md explicitly
    if abs.end_with?('/index.md')
      kind = 'maybe_redirect'
      suggestion ||= DocsAudit.repo_relative(abs.sub(%r{/index\.md\z}, ''))
      findings << {
        path: DocsAudit.repo_relative(file),
        line: lnk[:line],
        kind: kind,
        link_text: lnk[:text],
        target: target,
        suggestion: suggestion,
        severity: DocsAudit.p_severity(kind)
      }
    end
  end
end

findings = DocsAudit.sort_findings(findings)

DocsAudit.write_json(File.join(DocsAudit::TMP_AUDIT_DIR, 'links.json'), findings)

# Print summary counts
counts = Hash.new(0)
findings.each { |f| counts[f[:kind]] += 1 }
counts.keys.sort.each { |k| puts format('%-16s %4d', k, counts[k]) }

# Generate consolidated report if possible
def load_json_safe(path)
  return [] unless File.file?(path)
  JSON.parse(File.read(path), symbolize_names: true)
rescue StandardError
  []
end

links = findings
hyg = load_json_safe(File.join(DocsAudit::TMP_AUDIT_DIR, 'markdown_hygiene.json'))
rbx = load_json_safe(File.join(DocsAudit::TMP_AUDIT_DIR, 'ruby_examples.json'))
api = load_json_safe(File.join(DocsAudit::TMP_AUDIT_DIR, 'api_usage.json'))

# Aggregation
def one_liner_fix(issue)
  case issue[:kind] || issue[:ref_kind]
  when 'missing_file' then 'Fix relative path or create the missing page'
  when 'missing_anchor' then 'Adjust heading text or anchor slug to match'
  when 'maybe_redirect' then 'Update link to the canonical page (index.md)'
  when 'unclosed_fence' then 'Close the code fence with ``` on a new line'
  when 'missing_lang' then 'Add a language tag to the code fence'
  when 'unknown_lang' then 'Use a known fence language (e.g., ruby, bash)'
  when 'heading_jump' then 'Insert intermediate heading level or reduce depth'
  when 'duplicate_slug' then 'Rename heading to make slug unique'
  when 'trailing_ws' then 'Remove trailing whitespace on the line'
  when 'syntax_error' then 'Fix Ruby syntax until ruby -c passes'
  when 'yardoc_tag' then 'Remove YARD tags from prose or wrap in code block'
  when 'const' then 'Update or remove reference to missing constant'
  when 'method' then 'Update or remove reference to missing API method'
  else 'Triage'
  end
end

all = {
  links: links,
  hygiene: hyg,
  ruby: rbx,
  api: api
}

# Determine per-file severities and buckets
per_file = Hash.new { |h, k| h[k] = { p1: 0, p2: 0, p3: 0, kinds: Set.new, total: 0 } }
all.values.each do |arr|
  arr.each do |i|
    path = i[:path]
    sev = i[:severity] || DocsAudit.p_severity(i[:kind].to_s)
    case sev
    when 'P1' then per_file[path][:p1] += 1
    when 'P2' then per_file[path][:p2] += 1
    else per_file[path][:p3] += 1
    end
    per_file[path][:total] += 1
    per_file[path][:kinds] << (i[:kind] || i[:ref_kind])
  end
end

needs_rewrite = []
quick_fix = []
per_file.keys.sort.each do |path|
  meta = per_file[path]
  if meta[:p1] >= 3 || (meta[:p1] >= 1 && meta[:kinds].size >= 3) || meta[:total] >= 10
    needs_rewrite << path
  else
    quick_fix << path
  end
end

# Write consolidated markdown
md_lines = []
md_lines << "# Docs Audit Report"
md_lines << ""
md_lines << "Generated: #{Time.now.utc.iso8601}"
md_lines << "Repo root: #{DocsAudit::ROOT}"
md_lines << "Scripts: check_docs_links, check_docs_markdown, check_docs_ruby_examples, check_docs_api_usage"
md_lines << ""

# Tables helper
add_table = lambda do |title, rows, columns|
  md_lines << "### #{title}"
  md_lines << ""
  md_lines << columns.join(' | ')
  md_lines << columns.map { '---' }.join(' | ')
  rows.each { |r| md_lines << r.join(' | ') }
  md_lines << ""
end

# Links table
link_rows = links.map do |i|
  [i[:path], i[:line].to_s, i[:kind], i[:target].to_s, one_liner_fix(i), (i[:severity] || DocsAudit.p_severity(i[:kind])).to_s]
end
add_table.call('Links: broken/redirecting', link_rows, ['File', 'Line', 'Issue', 'Description', 'Proposed fix (one-liner)', 'Severity (P1–P3)'])

# Hygiene table
hyg_rows = hyg.map do |i|
  [i[:path], i[:line].to_s, i[:kind], i[:detail].to_s, one_liner_fix(i), (i[:severity] || DocsAudit.p_severity(i[:kind])).to_s]
end
add_table.call('Markdown hygiene', hyg_rows, ['File', 'Line', 'Issue', 'Description', 'Proposed fix (one-liner)', 'Severity (P1–P3)'])

# Ruby syntax table (only errors)
rb_rows = rbx.select { |i| i[:status] == 'syntax_error' }.map do |i|
  issue = 'syntax_error'
  desc = (i[:message] || '').gsub('|', '\\|')
  [i[:path], i[:line].to_s, issue, desc, one_liner_fix({ kind: issue }), DocsAudit.p_severity(issue)]
end
add_table.call('Ruby examples syntax', rb_rows, ['File', 'Line', 'Issue', 'Description', 'Proposed fix (one-liner)', 'Severity (P1–P3)'])

# API usage & YARD tags table
api_rows = api.map do |i|
  issue = i[:ref_kind]
  desc = "#{i[:name]} (#{i[:status]})"
  [i[:path], i[:line].to_s, issue, desc, one_liner_fix(i), (i[:severity] || DocsAudit.p_severity(issue)).to_s]
end
add_table.call('API usage & YARDoc leakage', api_rows, ['File', 'Line', 'Issue', 'Description', 'Proposed fix (one-liner)', 'Severity (P1–P3)'])

# Scope of change
md_lines << "### Scope of change"
md_lines << ""
md_lines << "- Quick mechanical fixes: #{quick_fix.sort.join(', ')}"
md_lines << "- Needs author rewrite: #{needs_rewrite.sort.join(', ')}"
md_lines << ""

# Appendix counts
counts_all = Hash.new(0)
all.values.each { |arr| arr.each { |i| counts_all[(i[:kind] || i[:ref_kind] || i[:status]).to_s] += 1 } }
md_lines << "### Appendix"
md_lines << ""
counts_all.keys.sort.each do |k|
  md_lines << "- #{k}: #{counts_all[k]}"
end
md_lines << ""
md_lines << "Ignore heuristics: external links ignored; pseudo-code markers ('...', 'YOUR_', '# pseudo', '<TBD>') skipped in Ruby checks; fence languages limited to a known set."

DocsAudit.atomic_write(File.join(DocsAudit::TMP_REFACTOR_DIR, 'docs_audit.md'), md_lines.join("\n"))

# Exit non-zero on any P1 in this script's findings
exit(1) if findings.any? { |f| f[:severity] == 'P1' }
